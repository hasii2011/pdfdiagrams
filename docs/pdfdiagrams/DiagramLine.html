<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>pdfdiagrams.DiagramLine API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pdfdiagrams.DiagramLine</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from logging import Logger
from logging import getLogger

from math import pi
from math import sin
from math import atan
from math import cos
from typing import Tuple

from fpdf import FPDF

from pdfdiagrams.Internal import ArrowPoints
from pdfdiagrams.Internal import DiamondPoints
from pdfdiagrams.Internal import PolygonPoints
from pdfdiagrams.Internal import PdfPosition

from pdfdiagrams.Definitions import DiagramPadding
from pdfdiagrams.Definitions import UmlLineDefinition
from pdfdiagrams.Definitions import LineType
from pdfdiagrams.Definitions import Position

from pdfdiagrams.DiagramCommon import DiagramCommon
from pdfdiagrams.Internal import ScanPoints

from pdfdiagrams.UnsupportedException import UnsupportedException


class DiagramLine:
    &#34;&#34;&#34;
    This class takes responsibility for drawing the various types of lines within the
    described UML classes.  End users generally do not directly use this class.
    It is split off as part of the separation of responsibility principle.
    &#34;&#34;&#34;
    INHERITANCE_ARROW_HEIGHT: int = 8
    DIAMOND_HEIGHT: int = 8

    def __init__(self, pdf: FPDF, diagramPadding: DiagramPadding, dpi: int):

        self.logger: Logger = getLogger(__name__)

        self._pdf: FPDF = pdf
        self._dpi: int  = dpi

        self._diagramPadding: diagramPadding  = diagramPadding

    def draw(self, lineDefinition: UmlLineDefinition):
        &#34;&#34;&#34;
        Draw the line described by the input parameter
        Args:
            lineDefinition:  Describes the line to draw
        &#34;&#34;&#34;

        source:      Position = lineDefinition.source
        destination: Position = lineDefinition.destination
        lineType:    LineType = lineDefinition.lineType

        if lineType == LineType.Inheritance:
            self._drawInheritanceArrow(src=source, dest=destination)
        elif lineType == LineType.Composition:
            self._drawCompositionSolidDiamond(src=source, dest=destination)
        elif lineType == LineType.Aggregation:
            self._drawAggregationDiamond(src=source, dest=destination)
        else:
            raise UnsupportedException(f&#39;Line definition type not supported: `{lineType}`&#39;)

    def _drawInheritanceArrow(self, src: Position, dest: Position):
        &#34;&#34;&#34;
        Must account for the margins and gaps between drawn shapes
        Must convert to points from screen coordinates
        Draw the arrow first
        Compute the mid point of the bottom line of the arrow
        That is where the line ends

        Args:
            src: start of line
            dest: end line line;  Arrow positioned here
        &#34;&#34;&#34;
        convertedSrc, convertedDest = self.__convertEndPoints(src, dest)

        points: ArrowPoints = self.__computeTheArrowVertices(convertedSrc, convertedDest)
        self.__drawPolygon(points)

        newEndPoint: PdfPosition = self.__computeMidPointOfBottomLine(points[0], points[2])

        self._pdf.line(x1=convertedSrc.x, y1=convertedSrc.y, x2=newEndPoint.x, y2=newEndPoint.y)

    def _drawCompositionSolidDiamond(self, src: Position, dest: Position):

        convertedSrc, convertedDest = self.__convertEndPoints(src, dest)
        points: DiamondPoints = self.__computeDiamondVertices(convertedSrc, convertedDest)

        self.__drawPolygon(points)
        self.__FillInDiamond(points)

        newEndPoint: PdfPosition = points[3]
        self._pdf.line(x1=convertedSrc.x, y1=convertedSrc.y, x2=newEndPoint.x, y2=newEndPoint.y)

    def _drawAggregationDiamond(self, src: Position, dest: Position):

        convertedSrc, convertedDest = self.__convertEndPoints(src, dest)
        points: ArrowPoints = self.__computeDiamondVertices(convertedSrc, convertedDest)
        self.__drawPolygon(points)

        newEndPoint: PdfPosition = points[3]

        self._pdf.line(x1=convertedSrc.x, y1=convertedSrc.y, x2=newEndPoint.x, y2=newEndPoint.y)

    def __convertEndPoints(self, src: Position, dest: Position) -&gt; Tuple[PdfPosition, PdfPosition]:

        verticalGap:   int = self._diagramPadding.verticalGap
        horizontalGap: int = self._diagramPadding.horizontalGap

        x1, y1 = DiagramCommon.convertPosition(pos=src,  dpi=self._dpi, verticalGap=verticalGap, horizontalGap=horizontalGap)
        x2, y2 = DiagramCommon.convertPosition(pos=dest, dpi=self._dpi, verticalGap=verticalGap, horizontalGap=horizontalGap)

        convertedSrc:  PdfPosition = PdfPosition(x1, y1)
        convertedDest: PdfPosition = PdfPosition(x2, y2)

        return convertedSrc, convertedDest

    def __computeTheArrowVertices(self, src: PdfPosition, dest: PdfPosition)  -&gt; ArrowPoints:
        &#34;&#34;&#34;
        Draw an arrow at the end of the line source-dest.

        Args:
            src:  points of the segment
            dest:  points of the segment

        Returns:
            A list of positions that describes a diamond to draw
        &#34;&#34;&#34;
        # x1: float = src.x
        # y1: float = src.y
        # x2: float = dest.x
        # y2: float = dest.y
        #
        # deltaX: float = x2 - x1
        # deltaY: float = y2 - y1
        deltaX, deltaY = self.__computeDeltaXDeltaY(src, dest)
        if abs(deltaX) &lt; 0.01:   # vertical segment
            if deltaY &gt; 0:
                alpha = -pi/2
            else:
                alpha = pi/2
        else:
            if deltaX == 0:
                alpha = pi/2
            else:
                alpha = atan(deltaY/deltaX)
        if deltaX &gt; 0:
            alpha += pi

        pi_6: float = pi/6      # radians for 30 degree angle

        alpha1: float = alpha + pi_6
        alpha2: float = alpha - pi_6
        size:   float = DiagramLine.INHERITANCE_ARROW_HEIGHT
        x2: float = dest.x
        y2: float = dest.y
        #
        # The names for the left and right points are correct for upward facing arrows
        # They are inverted for downward facing arrows
        #
        arrowTip:   PdfPosition = PdfPosition(x2, y2)
        rightPoint: PdfPosition = PdfPosition(x2 + size * cos(alpha1), y2 + size * sin(alpha1))
        leftPoint:  PdfPosition = PdfPosition(x2 + size * cos(alpha2), y2 + size * sin(alpha2))

        points: ArrowPoints = [rightPoint, arrowTip, leftPoint]

        return points

    def __computeDiamondVertices(self, src: PdfPosition, dest: PdfPosition) -&gt; DiamondPoints:
        &#34;&#34;&#34;
        Args:
            src:
            dest:
        &#34;&#34;&#34;
        pi_6: float = pi/6     # radians for 30 degree angle
        x2:   float = dest.x
        y2:   float = dest.y

        deltaX, deltaY = self.__computeDeltaXDeltaY(src, dest)

        if abs(deltaX) &lt; 0.01:  # vertical segment
            if deltaY &gt; 0:
                alpha = -pi/2
            else:
                alpha = pi/2
        else:
            if deltaX == 0:
                if deltaY &gt; 0:
                    alpha = pi/2
                else:
                    alpha = 3 * pi / 2
            else:
                alpha = atan(deltaY/deltaX)
        if deltaX &gt; 0:
            alpha += pi

        alpha1: float = alpha + pi_6
        alpha2: float = alpha - pi_6
        size:   int   = DiagramLine.DIAMOND_HEIGHT

        # noinspection PyListCreation
        points: DiamondPoints = []

        points.append((PdfPosition(x2 + size * cos(alpha1), y2 + size * sin(alpha1))))
        points.append(PdfPosition(x2, y2))
        points.append(PdfPosition(x2 + size * cos(alpha2), y2 + size * sin(alpha2)))
        points.append(PdfPosition(x2 + 2 * size * cos(alpha), y2 + 2 * size * sin(alpha)))

        return points

    def __drawPolygon(self, points: PolygonPoints):

        pdf: FPDF = self._pdf
        ptNumber: int = 0
        for point in points:

            x1: float = point.x
            y1: float = point.y

            if ptNumber == len(points) - 1:
                nextPoint = points[0]
                x2: float = nextPoint.x
                y2: float = nextPoint.y
                pdf.line(x1, y1, x2, y2)
                break
            else:
                nextPoint = points[ptNumber + 1]
                x2: float = nextPoint.x
                y2: float = nextPoint.y
                pdf.line(x1, y1, x2, y2)

            ptNumber += 1

    def __computeMidPointOfBottomLine(self, startPos: PdfPosition, endPos: PdfPosition) -&gt; PdfPosition:
        &#34;&#34;&#34;
        These two coordinates are the two end-points of the bottom leg of the inheritance arrow
        midPoint = (x1+x2/2, y1+y2/2)

        Args:
            startPos: start of line
            endPos:   end of line

        Returns:  Midpoint between startPos - endPos

        &#34;&#34;&#34;
        x1: float = startPos.x
        y1: float = startPos.y
        x2: float = endPos.x
        y2: float = endPos.y

        midX: float = (x1 + x2) / 2
        midY: float = (y1 + y2) / 2

        return PdfPosition(midX, midY)

    def __computeDeltaXDeltaY(self, src: PdfPosition, dest: PdfPosition) -&gt; Tuple[float, float]:

        x1: float = src.x
        y1: float = src.y
        x2: float = dest.x
        y2: float = dest.y

        deltaX: float = x2 - x1
        deltaY: float = y2 - y1

        return deltaX, deltaY

    def __FillInDiamond(self, points: DiamondPoints):
        &#34;&#34;&#34;

        Args:
            points:  The polygon that defines the composition diamond

        &#34;&#34;&#34;
        scanPoints: ScanPoints = DiagramCommon.buildScanPoints(points)

        startX: float = scanPoints.startScan.x
        startY: float = scanPoints.startScan.y

        endX: float = scanPoints.endScan.x
        endY: float = scanPoints.endScan.y

        x = startX
        while x &lt;= endX:
            y = startY
            while y &lt;= endY:
                if DiagramCommon.pointInsidePolygon(pos=PdfPosition(x, y), polygon=points):
                    self._pdf.line(x1=x, y1=y, x2=x, y2=y)
                y += 1
            x += 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pdfdiagrams.DiagramLine.DiagramLine"><code class="flex name class">
<span>class <span class="ident">DiagramLine</span></span>
<span>(</span><span>pdf: fpdf.fpdf.FPDF, diagramPadding: <a title="pdfdiagrams.Definitions.DiagramPadding" href="Definitions.html#pdfdiagrams.Definitions.DiagramPadding">DiagramPadding</a>, dpi: int)</span>
</code></dt>
<dd>
<div class="desc"><p>This class takes responsibility for drawing the various types of lines within the
described UML classes.
End users generally do not directly use this class.
It is split off as part of the separation of responsibility principle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DiagramLine:
    &#34;&#34;&#34;
    This class takes responsibility for drawing the various types of lines within the
    described UML classes.  End users generally do not directly use this class.
    It is split off as part of the separation of responsibility principle.
    &#34;&#34;&#34;
    INHERITANCE_ARROW_HEIGHT: int = 8
    DIAMOND_HEIGHT: int = 8

    def __init__(self, pdf: FPDF, diagramPadding: DiagramPadding, dpi: int):

        self.logger: Logger = getLogger(__name__)

        self._pdf: FPDF = pdf
        self._dpi: int  = dpi

        self._diagramPadding: diagramPadding  = diagramPadding

    def draw(self, lineDefinition: UmlLineDefinition):
        &#34;&#34;&#34;
        Draw the line described by the input parameter
        Args:
            lineDefinition:  Describes the line to draw
        &#34;&#34;&#34;

        source:      Position = lineDefinition.source
        destination: Position = lineDefinition.destination
        lineType:    LineType = lineDefinition.lineType

        if lineType == LineType.Inheritance:
            self._drawInheritanceArrow(src=source, dest=destination)
        elif lineType == LineType.Composition:
            self._drawCompositionSolidDiamond(src=source, dest=destination)
        elif lineType == LineType.Aggregation:
            self._drawAggregationDiamond(src=source, dest=destination)
        else:
            raise UnsupportedException(f&#39;Line definition type not supported: `{lineType}`&#39;)

    def _drawInheritanceArrow(self, src: Position, dest: Position):
        &#34;&#34;&#34;
        Must account for the margins and gaps between drawn shapes
        Must convert to points from screen coordinates
        Draw the arrow first
        Compute the mid point of the bottom line of the arrow
        That is where the line ends

        Args:
            src: start of line
            dest: end line line;  Arrow positioned here
        &#34;&#34;&#34;
        convertedSrc, convertedDest = self.__convertEndPoints(src, dest)

        points: ArrowPoints = self.__computeTheArrowVertices(convertedSrc, convertedDest)
        self.__drawPolygon(points)

        newEndPoint: PdfPosition = self.__computeMidPointOfBottomLine(points[0], points[2])

        self._pdf.line(x1=convertedSrc.x, y1=convertedSrc.y, x2=newEndPoint.x, y2=newEndPoint.y)

    def _drawCompositionSolidDiamond(self, src: Position, dest: Position):

        convertedSrc, convertedDest = self.__convertEndPoints(src, dest)
        points: DiamondPoints = self.__computeDiamondVertices(convertedSrc, convertedDest)

        self.__drawPolygon(points)
        self.__FillInDiamond(points)

        newEndPoint: PdfPosition = points[3]
        self._pdf.line(x1=convertedSrc.x, y1=convertedSrc.y, x2=newEndPoint.x, y2=newEndPoint.y)

    def _drawAggregationDiamond(self, src: Position, dest: Position):

        convertedSrc, convertedDest = self.__convertEndPoints(src, dest)
        points: ArrowPoints = self.__computeDiamondVertices(convertedSrc, convertedDest)
        self.__drawPolygon(points)

        newEndPoint: PdfPosition = points[3]

        self._pdf.line(x1=convertedSrc.x, y1=convertedSrc.y, x2=newEndPoint.x, y2=newEndPoint.y)

    def __convertEndPoints(self, src: Position, dest: Position) -&gt; Tuple[PdfPosition, PdfPosition]:

        verticalGap:   int = self._diagramPadding.verticalGap
        horizontalGap: int = self._diagramPadding.horizontalGap

        x1, y1 = DiagramCommon.convertPosition(pos=src,  dpi=self._dpi, verticalGap=verticalGap, horizontalGap=horizontalGap)
        x2, y2 = DiagramCommon.convertPosition(pos=dest, dpi=self._dpi, verticalGap=verticalGap, horizontalGap=horizontalGap)

        convertedSrc:  PdfPosition = PdfPosition(x1, y1)
        convertedDest: PdfPosition = PdfPosition(x2, y2)

        return convertedSrc, convertedDest

    def __computeTheArrowVertices(self, src: PdfPosition, dest: PdfPosition)  -&gt; ArrowPoints:
        &#34;&#34;&#34;
        Draw an arrow at the end of the line source-dest.

        Args:
            src:  points of the segment
            dest:  points of the segment

        Returns:
            A list of positions that describes a diamond to draw
        &#34;&#34;&#34;
        # x1: float = src.x
        # y1: float = src.y
        # x2: float = dest.x
        # y2: float = dest.y
        #
        # deltaX: float = x2 - x1
        # deltaY: float = y2 - y1
        deltaX, deltaY = self.__computeDeltaXDeltaY(src, dest)
        if abs(deltaX) &lt; 0.01:   # vertical segment
            if deltaY &gt; 0:
                alpha = -pi/2
            else:
                alpha = pi/2
        else:
            if deltaX == 0:
                alpha = pi/2
            else:
                alpha = atan(deltaY/deltaX)
        if deltaX &gt; 0:
            alpha += pi

        pi_6: float = pi/6      # radians for 30 degree angle

        alpha1: float = alpha + pi_6
        alpha2: float = alpha - pi_6
        size:   float = DiagramLine.INHERITANCE_ARROW_HEIGHT
        x2: float = dest.x
        y2: float = dest.y
        #
        # The names for the left and right points are correct for upward facing arrows
        # They are inverted for downward facing arrows
        #
        arrowTip:   PdfPosition = PdfPosition(x2, y2)
        rightPoint: PdfPosition = PdfPosition(x2 + size * cos(alpha1), y2 + size * sin(alpha1))
        leftPoint:  PdfPosition = PdfPosition(x2 + size * cos(alpha2), y2 + size * sin(alpha2))

        points: ArrowPoints = [rightPoint, arrowTip, leftPoint]

        return points

    def __computeDiamondVertices(self, src: PdfPosition, dest: PdfPosition) -&gt; DiamondPoints:
        &#34;&#34;&#34;
        Args:
            src:
            dest:
        &#34;&#34;&#34;
        pi_6: float = pi/6     # radians for 30 degree angle
        x2:   float = dest.x
        y2:   float = dest.y

        deltaX, deltaY = self.__computeDeltaXDeltaY(src, dest)

        if abs(deltaX) &lt; 0.01:  # vertical segment
            if deltaY &gt; 0:
                alpha = -pi/2
            else:
                alpha = pi/2
        else:
            if deltaX == 0:
                if deltaY &gt; 0:
                    alpha = pi/2
                else:
                    alpha = 3 * pi / 2
            else:
                alpha = atan(deltaY/deltaX)
        if deltaX &gt; 0:
            alpha += pi

        alpha1: float = alpha + pi_6
        alpha2: float = alpha - pi_6
        size:   int   = DiagramLine.DIAMOND_HEIGHT

        # noinspection PyListCreation
        points: DiamondPoints = []

        points.append((PdfPosition(x2 + size * cos(alpha1), y2 + size * sin(alpha1))))
        points.append(PdfPosition(x2, y2))
        points.append(PdfPosition(x2 + size * cos(alpha2), y2 + size * sin(alpha2)))
        points.append(PdfPosition(x2 + 2 * size * cos(alpha), y2 + 2 * size * sin(alpha)))

        return points

    def __drawPolygon(self, points: PolygonPoints):

        pdf: FPDF = self._pdf
        ptNumber: int = 0
        for point in points:

            x1: float = point.x
            y1: float = point.y

            if ptNumber == len(points) - 1:
                nextPoint = points[0]
                x2: float = nextPoint.x
                y2: float = nextPoint.y
                pdf.line(x1, y1, x2, y2)
                break
            else:
                nextPoint = points[ptNumber + 1]
                x2: float = nextPoint.x
                y2: float = nextPoint.y
                pdf.line(x1, y1, x2, y2)

            ptNumber += 1

    def __computeMidPointOfBottomLine(self, startPos: PdfPosition, endPos: PdfPosition) -&gt; PdfPosition:
        &#34;&#34;&#34;
        These two coordinates are the two end-points of the bottom leg of the inheritance arrow
        midPoint = (x1+x2/2, y1+y2/2)

        Args:
            startPos: start of line
            endPos:   end of line

        Returns:  Midpoint between startPos - endPos

        &#34;&#34;&#34;
        x1: float = startPos.x
        y1: float = startPos.y
        x2: float = endPos.x
        y2: float = endPos.y

        midX: float = (x1 + x2) / 2
        midY: float = (y1 + y2) / 2

        return PdfPosition(midX, midY)

    def __computeDeltaXDeltaY(self, src: PdfPosition, dest: PdfPosition) -&gt; Tuple[float, float]:

        x1: float = src.x
        y1: float = src.y
        x2: float = dest.x
        y2: float = dest.y

        deltaX: float = x2 - x1
        deltaY: float = y2 - y1

        return deltaX, deltaY

    def __FillInDiamond(self, points: DiamondPoints):
        &#34;&#34;&#34;

        Args:
            points:  The polygon that defines the composition diamond

        &#34;&#34;&#34;
        scanPoints: ScanPoints = DiagramCommon.buildScanPoints(points)

        startX: float = scanPoints.startScan.x
        startY: float = scanPoints.startScan.y

        endX: float = scanPoints.endScan.x
        endY: float = scanPoints.endScan.y

        x = startX
        while x &lt;= endX:
            y = startY
            while y &lt;= endY:
                if DiagramCommon.pointInsidePolygon(pos=PdfPosition(x, y), polygon=points):
                    self._pdf.line(x1=x, y1=y, x2=x, y2=y)
                y += 1
            x += 1</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pdfdiagrams.DiagramLine.DiagramLine.DIAMOND_HEIGHT"><code class="name">var <span class="ident">DIAMOND_HEIGHT</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdfdiagrams.DiagramLine.DiagramLine.INHERITANCE_ARROW_HEIGHT"><code class="name">var <span class="ident">INHERITANCE_ARROW_HEIGHT</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pdfdiagrams.DiagramLine.DiagramLine.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, lineDefinition: <a title="pdfdiagrams.Definitions.UmlLineDefinition" href="Definitions.html#pdfdiagrams.Definitions.UmlLineDefinition">UmlLineDefinition</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw the line described by the input parameter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lineDefinition</code></strong></dt>
<dd>Describes the line to draw</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, lineDefinition: UmlLineDefinition):
    &#34;&#34;&#34;
    Draw the line described by the input parameter
    Args:
        lineDefinition:  Describes the line to draw
    &#34;&#34;&#34;

    source:      Position = lineDefinition.source
    destination: Position = lineDefinition.destination
    lineType:    LineType = lineDefinition.lineType

    if lineType == LineType.Inheritance:
        self._drawInheritanceArrow(src=source, dest=destination)
    elif lineType == LineType.Composition:
        self._drawCompositionSolidDiamond(src=source, dest=destination)
    elif lineType == LineType.Aggregation:
        self._drawAggregationDiamond(src=source, dest=destination)
    else:
        raise UnsupportedException(f&#39;Line definition type not supported: `{lineType}`&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pdfdiagrams" href="index.html">pdfdiagrams</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pdfdiagrams.DiagramLine.DiagramLine" href="#pdfdiagrams.DiagramLine.DiagramLine">DiagramLine</a></code></h4>
<ul class="">
<li><code><a title="pdfdiagrams.DiagramLine.DiagramLine.DIAMOND_HEIGHT" href="#pdfdiagrams.DiagramLine.DiagramLine.DIAMOND_HEIGHT">DIAMOND_HEIGHT</a></code></li>
<li><code><a title="pdfdiagrams.DiagramLine.DiagramLine.INHERITANCE_ARROW_HEIGHT" href="#pdfdiagrams.DiagramLine.DiagramLine.INHERITANCE_ARROW_HEIGHT">INHERITANCE_ARROW_HEIGHT</a></code></li>
<li><code><a title="pdfdiagrams.DiagramLine.DiagramLine.draw" href="#pdfdiagrams.DiagramLine.DiagramLine.draw">draw</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>